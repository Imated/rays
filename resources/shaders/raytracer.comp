#version 460 core

layout(local_size_x=8, local_size_y=8) in;

layout(rgba32f, binding = 0) uniform image2D accumImage;

struct Material {
    vec3 color;
    float smoothness;
    vec3 emissiveColor;
    float emissiveStrength;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitInfo {
    bool didHit;
    float distance;
    vec3 hitPos;
    vec3 normal;
    Material material;
};

struct TriangleHitInfo
{
    bool didHit;
    float distance;
    vec3 hitPos;
    vec3 normal;
    Material material;
    int triIndex;
};

struct MeshInfo {
    uint firstTriangleIndex;
    uint numTriangles;
    vec4 boundingBoxMin;
    vec4 boundingBoxMax;
    vec4 color_smoothness;
    vec4 emissionColor_emissionStrength;
    vec4 pos;
    mat4 rotation;
    mat4 invRotation;
    vec4 scale;
};
layout (std430, binding = 2) buffer MeshBuffer {
    MeshInfo meshes[];
};

struct Triangle {
    vec4 posA;
    vec4 posB;
    vec4 posC;
    vec4 normalA;
    vec4 normalB;
    vec4 normalC;
};
layout (std430, binding = 1) readonly buffer TriangleBuffer {
    Triangle triangles[];
};

struct Sphere {
    vec4 pos_radius;
    vec4 color_smoothness;
    vec4 emissiveColor_strength;
};
layout (std430, binding = 0) readonly buffer SphereBuffer {
    Sphere spheres[];
};

struct BVHNode {
    vec4 min;
    vec4 max;
    uvec4 triIndex_triCount_childIndex;
};
layout (std430, binding = 3) readonly buffer NodeBuffer {
    BVHNode nodes[];
};

uniform uvec2 uResolution;
uniform uint renderedFrames;
uniform int samplesPerPixel;
uniform vec3 cameraPosition;
uniform mat3 cameraRotation;
uniform float uFocalLength;
uniform bool shouldAccumulate;

uint lcg(inout uint s) {
    s = 1664525u * s + 1013904223u;
    return s;
}
float rnd(inout uint s) {
    return uintBitsToFloat((lcg(s) >> 9) | 0x3f800000u) - 1.0;
}

vec3 randomDirection(inout uint rngState) {
    float z  = 1.0 - 2.0 * rnd(rngState);
    float a  = 6.28318530718 * rnd(rngState);
    float r  = sqrt(max(0.0, 1.0 - z*z));
    float ca = cos(a), sa = sin(a);
    return vec3(r*ca, r*sa, z);
}

bool intersectRayBoundingBox(Ray ray, vec3 boundsMin, vec3 boundsMax, float dst) {
    vec3 invDir = 1 / ray.direction;
    vec3 tMin = (boundsMin - ray.origin) * invDir;
    vec3 tMax = (boundsMax - ray.origin) * invDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return tNear <= tFar && (tNear < dst);
}

bool intersectRayTriangle(in Ray ray, in Triangle tri, float tMin, out HitInfo hitInfo)
{
    vec3 e1 = tri.posB.xyz - tri.posA.xyz;
    vec3 e2 = tri.posC.xyz - tri.posA.xyz;
    vec3 p  = cross(ray.direction, e2);
    float det = dot(e1, p);

    hitInfo.didHit = false;

    // parallel / nearly degenerate
    if (abs(det) < 1e-8)
        return false;

    float invDet = 1.0 / det;
    vec3  t = ray.origin - tri.posA.xyz;
    float u = dot(t, p) * invDet;
    if (u < 0.0 || u > 1.0)
        return false;

    vec3  q = cross(t, e1);
    float v = dot(ray.direction, q) * invDet;
    if (v < 0.0 || u + v > 1.0)
        return false;

    float dst = dot(e2, q) * invDet;
    if (dst <= tMin)
        return false;

    float w = 1.0 - u - v;

    hitInfo.didHit   = true;
    hitInfo.distance = dst;
    hitInfo.hitPos = ray.origin + dst * ray.direction;
    hitInfo.normal = normalize(tri.normalA.xyz * w + tri.normalB.xyz * u + tri.normalC.xyz * v);

    return true;
}

HitInfo intersectRayTriangleBVH(Ray ray) {
    HitInfo best;
    best.didHit = false;
    best.distance = 3.4e38;

    if (nodes.length() == 0)
    return best;

    uint stack[64];
    int sp = 0;
    stack[sp++] = 0u;

    while (sp > 0) {
        uint ni = stack[--sp];
        BVHNode n = nodes[ni];

        if (!intersectRayBoundingBox(ray, n.min.xyz, n.max.xyz, best.distance))
            continue;

        uint first = n.triIndex_triCount_childIndex.x;
        uint count = n.triIndex_triCount_childIndex.y;

        if (count > 0u) {
            float tMin = 1e-4;
            for (uint i = 0u; i < count; ++i) {
                Triangle tri = triangles[first + i];
                HitInfo h;
                if (intersectRayTriangle(ray, tri, tMin, h) && h.distance < best.distance) {
                    best = h;
                }
            }
        } else {
            uint left = n.triIndex_triCount_childIndex.z;
            uint right = left + 1u;
            if (right < nodes.length() && sp < 64)
                stack[sp++] = right;
            if (left  < nodes.length() && sp < 64)
                stack[sp++] = left;
        }
    }
    return best;
}

HitInfo intersectRaySphere(Ray ray, Sphere sphere) {
    vec3 oc = sphere.pos_radius.xyz - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float b = -2.0 * dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.pos_radius.w * sphere.pos_radius.w;
    float discriminant = b*b - 4.0 * a * c;

    HitInfo hitInfo;
    hitInfo.didHit = false;

    if (discriminant >= 0.0) {
        hitInfo.distance = (-b - sqrt(discriminant)) / (2.0 * a);

        if (hitInfo.distance > 0.0) {
            hitInfo.didHit = true;
            hitInfo.hitPos = ray.origin + ray.direction * hitInfo.distance;
            hitInfo.normal = normalize(hitInfo.hitPos - sphere.pos_radius.xyz);
            Material material;
            material.color = sphere.color_smoothness.xyz;
            material.emissiveColor = sphere.emissiveColor_strength.xyz;
            material.emissiveStrength = sphere.emissiveColor_strength.w;
            material.smoothness = sphere.color_smoothness.w;
            hitInfo.material = material;
        }
    }
    return hitInfo;
}

HitInfo calculateRayIntersection(Ray ray) {
    HitInfo closestHit;
    closestHit.didHit = false;
    closestHit.distance = 1.0 / 0.0;

    for (int i = 0; i < spheres.length(); i++) {
        Sphere sphere = spheres[i];
        HitInfo hitInfo = intersectRaySphere(ray, sphere);
        if (hitInfo.didHit && hitInfo.distance < closestHit.distance) {
            closestHit = hitInfo;
        }
    }

    for (int meshIndex = 0; meshIndex < meshes.length(); meshIndex++) {
        MeshInfo mesh = meshes[meshIndex];

        Ray localRay;
        localRay.origin = mat3(mesh.invRotation) * (ray.origin - mesh.pos.xyz);
        localRay.direction = normalize(mat3(mesh.invRotation) * ray.direction);

        HitInfo hitInfo = intersectRayTriangleBVH(localRay);

        if(hitInfo.didHit && hitInfo.distance < closestHit.distance) {
            closestHit = hitInfo;
            closestHit.hitPos = mat3(mesh.rotation) * closestHit.hitPos + mesh.pos.xyz;
            closestHit.normal = normalize(mat3(mesh.rotation) * closestHit.normal);

            Material material;
            material.color = mesh.color_smoothness.xyz;
            material.emissiveColor = mesh.emissionColor_emissionStrength.xyz;
            material.emissiveStrength = mesh.emissionColor_emissionStrength.w;
            material.smoothness = mesh.color_smoothness.w;
            closestHit.material = material;
        }
    }
    return closestHit;
}

vec3 GetEnvironmentLight(Ray ray) {
    float a = 0.5*(ray.direction.y + 1.0);
    return mix(vec3(1), vec3(0.5, 0.7, 1.0), a);
}

uniform int maxBounces;
vec3 traceRay(Ray ray, inout uint rngState) {
    vec3 inLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);
    for(int i = 0; i <= maxBounces; i++) {
        HitInfo info = calculateRayIntersection(ray);
        if(info.didHit) {
            ray.origin = info.hitPos + 1e-5 * info.normal;
            Material material = info.material;
            vec3 diffuseDir = normalize(info.normal + randomDirection(rngState));
            vec3 specularDir = reflect(normalize(ray.direction), info.normal);
            ray.direction = normalize(mix(diffuseDir, specularDir, clamp(material.smoothness, 0.0, 1.0)));
            vec3 emittedLight = material.emissiveColor * material.emissiveStrength;
            inLight += emittedLight * rayColor;
            rayColor *= material.color;
            //return info.normal * 0.5 + 0.5;
        }
        else
        {
            inLight += GetEnvironmentLight(ray) * rayColor;
            break;
        }
    }
    return inLight;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (pixelCoord.x >= int(uResolution.x) || pixelCoord.y >= int(uResolution.y))
        return;
    uint rngState = pixelCoord.x * uResolution.x + pixelCoord.y + renderedFrames * 71933u;
    vec2 pixelCenter = vec2(pixelCoord) + vec2(rnd(rngState), rnd(rngState));
    vec2 ndc = (pixelCenter - vec2(uResolution) * 0.5);
    vec3 dir = cameraRotation * normalize(vec3(ndc, uFocalLength));
    Ray ray = Ray(cameraPosition, dir);

    vec3 curr = vec3(0);
    for(int rayIndex = 0; rayIndex < samplesPerPixel; rayIndex++)
        curr += traceRay(ray, rngState);
    curr /= float(samplesPerPixel);

    vec4 prev = imageLoad(accumImage, pixelCoord);
    float alpha = 1.0 / float(renderedFrames + 1u);
    vec3 outCol = mix(prev.rgb, curr, alpha);
    imageStore(accumImage, pixelCoord, vec4(outCol, 1.0));
}