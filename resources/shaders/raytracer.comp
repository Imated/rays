#version 460 core

layout(local_size_x=16, local_size_y=16) in;

layout(rgba32f, binding = 0) uniform image2D accumImage;

struct Material {
    vec3 color;
    float smoothness;
    vec3 emissiveColor;
    float emissiveStrength;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitInfo {
    bool didHit;
    float distance;
    vec3 hitPos;
    vec3 normal;
    Material material;
};

struct Sphere {
    vec3 pos;
    float radius;
    vec3 color;
    float smoothness;
    vec3 emissiveColor;
    float emissiveStrength;
};
layout (std430, binding = 0) buffer SphereBuffer {
    Sphere spheres[];
};

uniform uvec2 uResolution;
uniform uint renderedFrames;
uniform int samplesPerPixel;
uniform vec3 cameraPosition;
uniform mat3 cameraRotation;
uniform float uFocalLength;
uniform bool shouldAccumulate;

uint hash_u32(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float rnd(inout uint s) {
    s = hash_u32(s);
    return float(s) * (1.0/4294967296.0);
}

float randomValueNormalDistribution(inout uint rngState) {
    float u = clamp(rnd(rngState), 1e-7, 1.0 - 1e-7);
    float theta = 6.2831853 * rnd(rngState);
    float rho   = sqrt(-2.0 * log(u));
    return rho * cos(theta);
}
vec3 randomDirection(inout uint rngState) {
    float x = randomValueNormalDistribution(rngState);
    float y = randomValueNormalDistribution(rngState);
    float z = randomValueNormalDistribution(rngState);
    return normalize(vec3(x, y, z));
}

vec2 randomDirectionInCircle(inout uint rngState) {
    float theta = rnd(rngState) * 360;
    return vec2(cos(theta), sin(theta));
}

HitInfo intersectRaySphere(Ray ray, Sphere sphere) {
    vec3 oc = sphere.pos - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float b = -2.0 * dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.radius*sphere.radius;
    float discriminant = b*b - 4.0 * a * c;

    HitInfo hitInfo;
    hitInfo.didHit = false;

    if (discriminant >= 0.0) {
        hitInfo.distance = (-b - sqrt(discriminant)) / (2.0 * a);

        if (hitInfo.distance > 0.0) {
            hitInfo.didHit = true;
            hitInfo.hitPos = ray.origin + ray.direction * hitInfo.distance;
            hitInfo.normal = normalize(hitInfo.hitPos - sphere.pos);
            Material material;
            material.color = sphere.color;
            material.emissiveColor = sphere.emissiveColor;
            material.emissiveStrength = sphere.emissiveStrength;
            material.smoothness = sphere.smoothness;
            hitInfo.material = material;
        }
    }
    return hitInfo;
}

HitInfo calculateRayIntersection(Ray ray) {
    HitInfo closestHit;
    closestHit.didHit = false;
    closestHit.distance = 1.0 / 0.0;

    for (int i = 0; i < spheres.length(); i++) {
        Sphere sphere = spheres[i];
        HitInfo hitInfo = intersectRaySphere(ray, sphere);
        if (hitInfo.didHit && hitInfo.distance < closestHit.distance) {
            closestHit = hitInfo;
        }
    }
    return closestHit;
}

vec3 GetEnvironmentLight(Ray ray) {
    float a = 0.5*(ray.direction.y + 1.0);
    return mix(vec3(1), vec3(0.5, 0.7, 1.0), a);
}

uniform int maxBounces;
vec3 traceRay(Ray ray, inout uint rngState) {
    vec3 inLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);
    for(int i = 0; i <= maxBounces; i++) {
        HitInfo info = calculateRayIntersection(ray);
        if(info.didHit) {
            ray.origin = info.hitPos + info.normal * 1e-4;
            Material material = info.material;
            vec3 diffuseDir = normalize(info.normal + randomDirection(rngState));
            vec3 specularDir = reflect(normalize(ray.direction), info.normal);
            ray.direction = normalize(mix(diffuseDir, specularDir, clamp(material.smoothness, 0.0, 1.0)));
            vec3 emittedLight = material.emissiveColor * material.emissiveStrength;
            inLight += emittedLight * rayColor;
            rayColor *= material.color;
        }
        else
        {
            inLight += GetEnvironmentLight(ray) * rayColor;
            break;
        }
    }
    return inLight;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (pixelCoord.x >= int(uResolution.x) || pixelCoord.y >= int(uResolution.y))
        return;
    uint rngState = pixelCoord.x * uResolution.x + pixelCoord.y + renderedFrames * 71933u;
    vec2 pixelCenter = vec2(pixelCoord) + rnd(rngState);
    vec2 ndc = (pixelCenter - vec2(uResolution) * 0.5);
    vec3 dir = cameraRotation * normalize(vec3(ndc, uFocalLength));
    Ray ray = Ray(cameraPosition, dir);

    vec3 curr = vec3(0);
    for(int rayIndex = 0; rayIndex < samplesPerPixel; rayIndex++)
        curr += traceRay(ray, rngState);
    curr /= float(samplesPerPixel);

    vec4 prev = imageLoad(accumImage, pixelCoord);
    float alpha = (shouldAccumulate != false) ? (1.0 / float(renderedFrames + 1u)) : 1.0;
    vec3 outCol = mix(prev.rgb, curr, alpha);
    imageStore(accumImage, pixelCoord, vec4(outCol, 1.0));
}